package RH::Louie::${baseName}::Client;
#
# Auto generated by Management Information Systems.
# PLEASE DO NOT EDIT, YOUR CHANGES WILL BE WIPED OUT AT A LATER STAGE!
#
# =============================================================================
# Module: RH::Louie::${baseName}
# Contacts: Management Information Systems
# =============================================================================

=head1 NAME

F<${baseName}> - Client for communicating with the LoUIE ${serviceName} service

=head1 SYNOPSIS

=head1 DESCRIPTION

Simple client to communicate to the LoUIE ${serviceName} service.

The following functions are provided (and exported) by this module:

=cut

# =============================================================================

use strict;
use warnings;
use RH::Louie::Session;
use RH::Pb::Datatype;
use RH::Pb::${baseName}::${baseName};

use constant CLASS  => 'class';
use base qw(Logging::Base);

my $LOUIE = {
    host => '${info.getHost()}',
    port => '8080',
    servlet => '/${info.getGateway()}/pb',
    apptype => 'application/x-protobuf',
};

sub new {
    # establish class
    my ($prototype, $options) = @_;
    my ($class) = ref($prototype) || $prototype;

    # create $self
    my $self = {};
    bless($self, $class);

    # store class
    $self->{CLASS()} = $class;

    # process parameter(s)
    $self->_initialize( $options );

    # return self
    return $self;
}

sub _initialize {
    my ($self, $options) = @_;

    if ( defined $options ) {
        my $louieHash = {};
        for my $k ( keys %{$LOUIE} ) {
            if ( exists $options->{$k} ) {
                $louieHash->{$k} = $options->{$k};
            }
            else {
                $louieHash->{$k} = $LOUIE->{$k};
            }
        }
        $self->{_client} = RH::Louie::Session->new( $louieHash );
    }
    else {
        $self->{_client} = RH::Louie::Session->new( $LOUIE );
    }

    $self->{_service} = '${serviceName}';

    return;
}



#foreach($method in $info.methodInfos)
#if ( !$method.isDeprecated() )

# -----------------------------------------------------------------------------

=over 4

=item ${method.name}($args)

${method.getDescription()}

=back

=cut

sub ${method.name} {
    my ($self, $args) = @_;
#foreach($param in $method.getParameters())

    my $${param.getName()};
#if(!$method.isLouieDataType($param.getPbType()))
    $${param.getName()} = $args->{${param.getName()}};
#else
    if (( defined $args->{${param.getName()}} ) and ( ref($args->{${param.getName()}}) ne 'RH::Pb::${param.getPbType()}' )) {
        $${param.getName()} = RH::Pb::${param.getPbType()}->new();
#if( $method.getType($param.getPbType()) == "list" )
        push(@{$${param.getName()}->{${method.getPbArg($param.getPbType())}}}, @{$args->{${param.getName()}}});

#else
        $${param.getName()}->{${method.getPbArg($param.getPbType())}} = $args->{${param.getName()}};
#end
    }
    else {
        $${param.getName()} = $args->{${param.getName()}};
    }
#end
#end

    my $decode;
    if (!defined $args->{decode} ) {
        $decode = '${method.getReturnType()}->decode($pb)';
    }
    else {
        $decode = $args->{decode};
    }

    my $pbs = $self->{_client}->request(
        $self->{_service},
        '${method.name}',
        [ ${method.getParamNameString()} ],
    );
    my @list = ();
    foreach my $pb (@{$pbs}) {
        push( @list, eval($decode) );
    }
    return \@list;
}

#end
#end


1;
