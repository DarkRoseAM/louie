/*** GENERATED FROM ${info.inputFile} - DO NOT EDIT  ***/

/*
 * ${className}.java
 */
package ${info.packageName};

import java.lang.annotation.Annotation;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import java.util.List;

import com.rhythm.louie.Classes;
import com.rhythm.louie.Delegate;
import com.rhythm.louie.server.Server;
import com.rhythm.louie.server.ServiceProperties;
import com.rhythm.louie.connection.LouieConnection;
import com.rhythm.louie.connection.LouieConnectionFactory;
import com.rhythm.louie.CacheDelegate;
import com.rhythm.louie.DAO;
import com.rhythm.louie.Router;

import com.rhythm.pb.command.ServiceFactory;

public class ${className} implements ServiceFactory {

    private static final String serviceName = "${info.serviceName}";

    private ${className}() {}

    public static ${className} getInstance() {
        return Holder.INSTANCE;
    }

    private static class Holder {
        private static final ${className} INSTANCE = new ${className}();
    }

    @Override
    public String getServiceName() {
        return serviceName;
    }

    public ${info.serviceClassName} getServiceClient() throws Exception {
        return getService().getDelegate();
    }

    private static ${baseName}ServiceHandler service;

    @Override
    @SuppressWarnings("unchecked")
    public synchronized ${baseName}ServiceHandler getService() throws Exception {
        if (service!=null) {
            return service;
        }

        ServiceProperties props = ServiceProperties.getServiceProperties(serviceName);
        
        ${info.serviceClassName} serviceImpl;
        if (useRemoteDAO(props)) {
            Server PRIMARY = Server.getServer(props.getMain());
            LouieConnection connection = LouieConnectionFactory.getConnectionForServer(PRIMARY);
            serviceImpl = new ${baseName}RemoteService(connection);
        } else {
            serviceImpl = loadLayer(props.getDAO(), "${baseName}DAO", DAO.class, false);
        }
        if (serviceImpl==null) {
            throw new Exception("Must define at least a DAO layer");
        }
        
        ${info.serviceClassName} router = loadLayer(props.getRouter(), null, Router.class, true);
        if (router!=null) {
            ((Delegate<${info.serviceClassName}>)router).setDelegate(serviceImpl);
            serviceImpl = router;
        }
        
        if (props.isCachingOn()) {
            ${info.serviceClassName} cache = loadLayer(props.getCache(), "${baseName}CacheDelegate", CacheDelegate.class, true);
            if (cache!=null) {
                ((Delegate<${info.serviceClassName}>)cache).setDelegate(serviceImpl);
                serviceImpl = cache;
            }
        }
        
        service = new ${baseName}ServiceHandler();
        service.setDelegate(serviceImpl);
        return service;
    }

    private boolean useRemoteDAO(ServiceProperties props) throws Exception {
        if (props.isCentralized()) {
            Server PRIMARY = Server.getServer(props.getMain());
            if (PRIMARY == null) {
                throw new Exception("Cannot establish service!  Unknown MAIN server: " + props.getMain());
            }

            if (!Server.LOCAL.getLocation().equals(PRIMARY.getLocation())) {
                return true;
            }
        }
        return false;
    }

    private ${info.serviceClassName} loadLayer(String property, String defaultName,
            Class<? extends Annotation> annotation, boolean delegate) throws Exception {
        Class<?> layer = null;
        if (property==null) {
            // no layer override found, so search for the class tagged with the annotation

            List<Class<?>> classes = Classes.getTypesAnnotatedWith("${info.packageName}", annotation);
            if (classes.size()>1) {
                throw new Exception("Multiple @"+annotation.getSimpleName()+" classes found");
            } else if (classes.size()==1) {
                layer = classes.iterator().next();
            } else if (defaultName!=null && !defaultName.isEmpty()) {
                // check to see if the default exists, this helps support legacy behavior
                try {
                    layer = Class.forName("${info.packageName}."+defaultName);
                } catch (ClassNotFoundException e) {}
            }
        } else if (!property.isEmpty()) {
            // Attempt to load the override class
            layer = Class.forName(property);
        }
        if (layer == null) {
            return null;
        } else {
            if (!${info.serviceClassName}.class.isAssignableFrom(layer)) {
                throw new Exception(layer.getCanonicalName()+" does not implement ${info.serviceClassName}");
            }
            if (delegate) {
                if (!Delegate.class.isAssignableFrom(layer)) {
                    throw new Exception(layer.getCanonicalName()+" must implement Delegate<${info.serviceClassName}>");
                }
                for (Type genericInterface : layer.getGenericInterfaces()) {
                    if (genericInterface instanceof Delegate) {
                        Type[] genericTypes = ((ParameterizedType) genericInterface).getActualTypeArguments();
                        for (Type genericType : genericTypes) {
                            if (!(genericType instanceof ${info.serviceClassName})) {
                                throw new Exception(layer.getCanonicalName()+" must implement Delegate<${info.serviceClassName}>");
                            }
                        }
                    }
                }
            }
            return (${info.serviceClassName}) layer.newInstance();
        }
    }
}