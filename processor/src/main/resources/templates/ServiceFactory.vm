/*** GENERATED FROM ${info.inputFile} - DO NOT EDIT  ***/

/*
 * ${className}.java
 *
 * Copyright (c) 2013 Rhythm & Hues Studios. All rights reserved.
 */
package ${info.packageName};

import java.lang.annotation.Annotation;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import java.util.Set;

import org.reflections.Reflections;
import org.reflections.scanners.TypeAnnotationsScanner;

import com.rhythm.louie.Delegate;
import com.rhythm.louie.Server;
import com.rhythm.louie.ServiceProperties;
import com.rhythm.louie.connection.LouieConnection;
import com.rhythm.louie.connection.LouieConnectionFactory;
import com.rhythm.louie.process.CacheDelegate;
import com.rhythm.louie.process.DAO;
import com.rhythm.louie.process.Router;

import com.rhythm.pb.command.Service;
import com.rhythm.pb.command.ServiceFactory;

public class ${className} implements ServiceFactory {

    private static final String serviceName = "${info.serviceName}";

    private ${className}() {}

    public static ${className} getInstance() {
        return Holder.INSTANCE;
    }

    private static class Holder {
        private static final ${className} INSTANCE = new ${className}();
    }

    @Override
    public String getServiceName() {
        return serviceName;
    }

    public ${baseName}Client getServiceClient() throws Exception {
        return getService().getDelegate();
    }

    private static ${baseName}ServiceHandler service;

    @Override
    @SuppressWarnings("unchecked")
    public synchronized ${baseName}ServiceHandler getService() throws Exception {
        if (service!=null) {
            return service;
        }

        ServiceProperties props = ServiceProperties.getServiceProperties(serviceName);
        Reflections reflections = new Reflections("${info.packageName}");
        
        ${baseName}Client serviceClient;
        if (useRemoteDAO(props)) {
            Server PRIMARY = Server.getServer(props.getMain());
            LouieConnection connection = LouieConnectionFactory.getConnectionForServer(PRIMARY);
            serviceClient = ${baseName}ClientFactory.getClient(connection);
        } else {
            serviceClient = loadLayer(props.getDAO(), "${baseName}DAO", reflections, DAO.class, false);
        }
        if (serviceClient==null) {
            throw new Exception("Must define at least a DAO layer");
        }
        
        ${baseName}Client router = loadLayer(props.getRouter(),null,reflections,Router.class, true);
        if (router!=null) {
            ((Delegate<${baseName}Client>)router).setDelegate(serviceClient);
            serviceClient = router;
        }
        
        if (props.isCachingOn()) {
            ${baseName}Client cache = loadLayer(props.getCache(),"${baseName}CacheDelegate",reflections,CacheDelegate.class,true);
            if (cache!=null) {
                ((Delegate<${baseName}Client>)cache).setDelegate(serviceClient);
                serviceClient = cache;
            }
        }
        
        service = new ${baseName}ServiceHandler();
        service.setDelegate(serviceClient);
        return service;
    }

    private boolean useRemoteDAO(ServiceProperties props) throws Exception {
        if (props.isCentralized()) {
            Server PRIMARY = Server.getServer(props.getMain());
            if (PRIMARY == null) {
                throw new Exception("Cannot establish service!  Unknown MAIN server: " + props.getMain());
            }

            if (!Server.LOCAL.getLocation().equals(PRIMARY.getLocation())) {
                return true;
            }
        }
        return false;
    }

    private ${baseName}Client loadLayer(String property, String defaultName,
            Reflections reflections, Class<? extends Annotation> annotation, boolean delegate) throws Exception {
        Class<?> layer = null;
        if (property==null) {
            // no layer override found, so search for the class tagged with the annotation
            Set<Class<?>> caches = reflections.getTypesAnnotatedWith(annotation);
            if (caches.size()>1) {
                throw new Exception("Multiple @"+annotation.getSimpleName()+" layers found");
            } else if (caches.size()==1) {
                layer = caches.iterator().next();
            } else if (defaultName!=null && !defaultName.isEmpty()) {
                // check to see if the default exists, this helps support legacy behavior
                try {
                    layer = Class.forName("${info.packageName}."+defaultName);
                } catch (ClassNotFoundException e) {}
            }
        } else if (!property.isEmpty()) {
            // Attempt to load the override class
            layer = Class.forName(property);
        }
        if (layer == null) {
            return null;
        } else {
            if (!${baseName}Client.class.isAssignableFrom(layer)) {
                throw new Exception(layer.getCanonicalName()+" does not implement ${baseName}Client");
            }
            if (delegate) {
                if (!Delegate.class.isAssignableFrom(layer)) {
                    throw new Exception(layer.getCanonicalName()+" must implement Delegate<${baseName}Client>");
                }
                for (Type genericInterface : layer.getGenericInterfaces()) {
                    if (genericInterface instanceof Delegate) {
                        Type[] genericTypes = ((ParameterizedType) genericInterface).getActualTypeArguments();
                        for (Type genericType : genericTypes) {
                            if (!(genericType instanceof ${baseName}Client)) {
                                throw new Exception(layer.getCanonicalName()+" must implement Delegate<${baseName}Client>");
                            }
                        }
                    }
                }
            }
            return (${baseName}Client) layer.newInstance();
        }
    }
}