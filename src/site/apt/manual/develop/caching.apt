 ------
 Caching
 ------

Caching

 Many services can enhance their performance, especially in multi-datacenter installations, by including a caching layer in their service stack. Support for a caching layer, as well as overall cache management are built into the core framework. The internally supported caching structures utilize {{{http://code.google.com/p/guava-libraries/}Guava Cache Libraries}}. 

* Cache Delegate Service Layer

 You can hypothetically use caching on any layer in your service stack, however this can limit your flexibility as your networking demands evolve. As part of the preferred Louie design pattern, caching should be separted into its own layer. This allows fir easily enabling caching on a per deployment basis. The needs of every service can very widely, so this pattern of course is not applicable in all cases.

 To aid in the development of caching layers, and for readability, Louie provides a @CacheDelegate annotation. A service can only have one layer tagged as @CacheDelegate. This layer is automatically included in the service stack if no layers are configured for a service. If you are using custom layers, you can reference this layer in the configurations with the "cache" tag, for example:

+---------+
<service name="employee" enable="true">
  <layers>	 
    <cache />
    <layer class="com.rhythm.employee.EmployeeVariantDAO" />
  </layers>
</service>
+---------+

* Construction the Service Layer

 In order to tap into the core Louie cache management, a service layer must implement 2 interfaces:

 * The service interface - all layers for a service must implement the actual service interface

 * com.rhythm.louie.Delegate - All non-terminating layers must provide this as a means for the Service Manager to construct the service stack.

 As a means to helping this situation, a DelegateAdapter is autogenerated for every service. This adapter class provides a pass through for all methods defined for the service. Your cache layer can simply inherit from the DelegateAdapter and then override the methods that need caching.

* Cache Configuration

 To register caches with the internal Louie Cache management, you first need to create a CacheManager. You provide a name to uniquely identify the cache, usually the service name. The cache manager has a variety of cache factory methods that will create and register the cache. Upon creation you can specify specs for the caches directly to the internal Guava cache. Here is an example of creating a cache with a size limit, and an expiration. 


* Types of Caches

** Basic Cache 

 This works as essentially just a map, where you can insert items by calling put(key, value). 

 An example of creating a basic cache with a size limit, and an expiration. 

+-----+
private final GuavaCache<String, Employee> EMPLOYEE_CACHE;
public EmployeeCacheDelegate() {
    cacheManager = CacheManager.createIfNeeded(SERVICE_NAME);
       
    EMPLOYEE_CACHE = cacheManager.guavaCache("Employees",
           "maximumSize=200,expireAfterWrite=12h");
}

// Must manually populate the cache on misses.
// Simultaneous calls will cause the Employee to be loaded from the delegate multiple times.
public Employee getEmployee(String uname) throws Exception {
    Employee emp = EMPLOYEE_CACHE.get(uname);
    if (emp==null) {
        emp = getDelegate().getEmployee(uname);
        EMPLOYEE_CACHE.put(uname,emp);
    }
    return emp;
}

+-----+

** Loading Cache

 Upon creation you attach a com.google.common.cache.CacheLoader. When get(key) is called on the cache for a missing key, the corresponding load() function is called on the CacheLoader. This is the preferrable means of caching, as this allows the cache to synchronize on the key level, ie simultaneous calls to the same value will not each try to load the value. You can also implement the loadAll of a CacheLoader to more efficiently load multiple items.

 An example of a cache using a loader:

+-----+
private final GuavaLoadingCache<String, Employee> EMPLOYEE_CACHE;
public EmployeeCacheDelegate() {
    cacheManager = CacheManager.createIfNeeded(SERVICE_NAME);
       
    EMPLOYEE_CACHE = cacheManager.guavaLoadingCache("Employees",
           "maximumSize=200,expireAfterWrite=12h", new EmployeeLoader());
}

private class EmployeeLoader extends CacheLoader<String, Employee> {
    @Override
    public Employee load(String uname) throws Exception {
        return getDelegate().getEmployee(uname);
    }
}

// No manual population or synchronization needed
public Employee getEmployee(String uname) throws Exception {
    return EMPLOYEE_CACHE.get(uname);
}
+-----+

** Supplier Cache

 Essentially this functions as a singleton cache. Useful for storing a single item, rather than a map of key->value. Using a supplied com.google.common.base.Supplier, this cache effectively works like a loading cache, but only for a single item. 
    
 An example that uses a supplier to load a single value, not based on a key. SupplierCaches can also be configured to expire. Note: Supplier's get() cannot throw Exceptions, so they must be caught. The below example is not really a sufficient way to deal with this, but just an illustration of the process.

+-----+
private final SupplierCache<List<Employee>> EMPLOYEE_CACHE;
public EmployeeCacheDelegate() {
    cacheManager = CacheManager.createIfNeeded(SERVICE_NAME);
       
    ALL_EMPLOYEE_CACHE = cacheManager.supplierCache("Employees",
           new EmployeeSupplier(), 12, TimeUnit.HOURS);
}

private class EmployeeSupplier implements Supplier<List<Employee>> {
    @Override
    public List<Employee> get() {
        try {
            return getDelegate().getAllEmployees();
        } catch (Exception e) {
            LoggerFactory.getLogger(EmployeeCacheDelegate.class).error("Error looking up employees",e);
            return Collections.emptyList();
        }
    }
}
+-----+

